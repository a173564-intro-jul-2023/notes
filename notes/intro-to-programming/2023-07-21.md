- Loose Coupling
	- The ability to change something without breaking anything else
	- Does part B expect something specific from part A?
	- The more things are coupled, the less ability we have to change things
- Should rely on a contract, not an implementation
	- Implementation of one feature should not change how another feature acts
	- Changing the BonusCalculator should not make all the BankAccount tests fail
- SOLID Principles
- Interfaces
	- Starts with I
	- Essentially a job description
	- Necessary to create instance of class its being called/created in
	- Will throw a NullReferenceException if it hasn't been assigned a value
		- Happen super often, will crash entire software
		- https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/
	- Create a constructor
		- "Don't create BankAccount until I can give you something to calculate bonus"
		- Will throw a compiler error without
	- Have to manually make public, or will get Inconsistent Accessibility error
	- Can create classes in tests that implement the interface (DummyBonusCalculator)
		- Can also just install Moq (new Mock\<InterfaceName>().Object)
		- Moq is dummy by default (returns default value)
		- Moq can also be stubbed (setup what should return)
	- Create classes that implement the interface
		- Ex: public class ClassName : InterfaceName
- Write the code you wish you had
- Logger testing
	- Can use verify function to see if method was called with correct parameters
	- Will indicate whether or not it was called and what it was called with
	- Ex: Console.WriteLine() is a logger
	- Can add how many times it should be called
		- Ex: Times.Never / Times.Once / Times.Exactly(5)
- Distributed computing
	- Having a mainframe server was dangerous, if it went down, that was the end
	- Things are spread across several servers
	- Leads to cascading failures when one server goes down and the others are reliant on it
- Netflix ChaosMonkey randomly crashes servers to test reliability 